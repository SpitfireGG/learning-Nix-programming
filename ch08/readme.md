# Debugging Techniques

This document explains the Nix code snippets provided in the accompanying file (e.g., `debugging.nix`), which demonstrate various techniques for debugging Nix expressions. Understanding these techniques is crucial for diagnosing issues in Nix code, which often behaves differently from imperative languages due to its lazy evaluation and functional nature.

**Note:** To observe the output from tracing functions (`trace`, `traceVal`, `traceValFn`, `traceSeq`), you generally need to evaluate the Nix expression using commands like `nix eval --show-trace .#attributeName` or see structured output with `nix eval --json .#attributeName | jq`.

##  Debugging Technique flow

The code examples progress from basic tracing to more advanced error handling and validation methods.

1.  **Basic Tracing (`builtins.trace`)**
    *   **Concept:** This is the most fundamental tracing tool. `builtins.trace` takes a message (string) and a value. When Nix evaluates this expression, it first prints the message to the standard error output (as a side effect) and *then* returns the second argument (the value) unchanged.
    *   **Use Case:** Useful for simple "printf debugging" – confirming if a certain code path is executed or printing simple status messages during evaluation without altering the program's result.
    *   **Code Link:** Section 1 demonstrates using `trace` within an `if/then/else` to show which branch is taken based on type comparison.

2.  **Simple Value Inspection (`lib.debug.traceVal`)**
    *   **Concept:** A convenience function from the Nixpkgs library (`lib`). `lib.debug.traceVal` takes a label (string) and a value. It prints the label followed by the value, and then returns the original value. It's often slightly cleaner than `builtins.trace` when you just want to see what a value *is* at a certain point.
    *   **Use Case:** Quickly printing the value of a variable or intermediate expression during evaluation.
    *   **Code Link:** Section 2 shows its most basic usage, tracing a simple string value.

3.  **Custom Value Formatting (`lib.debug.traceValFn`)**
    *   **Concept:** Another `lib` helper that offers more control over the trace message. `lib.debug.traceValFn` takes a *function* as its first argument. This function receives the value being traced and should return a string message. `traceValFn` then prints this custom message and returns the original (second argument) value.
    *   **Use Case:** Essential for inspecting complex data structures (like attribute sets or lists) where you want to format the output meaningfully, perhaps converting parts to JSON or extracting specific fields for the trace message.
    *   **Code Link:** Section 3 demonstrates formatting an attribute set into a JSON string within the trace message.

4.  **Runtime Type Checking Example**
    *   **Concept:** This section applies `builtins.trace` in a practical scenario: checking types at runtime. It uses `builtins.typeOf` to compare the types of two variables and uses `trace` to report whether they match or mismatch, potentially showing a conversion step.
    *   **Use Case:** Debugging type errors or understanding implicit type conversions (or lack thereof) in your Nix logic.
    *   **Code Link:** Section 4 shows checking types and tracing the outcome, including a simulated conversion if types mismatch.

5.  **Debugging File Operations**
    *   **Concept:** This demonstrates using `lib.debug.traceValFn` to debug operations involving the filesystem. The formatting function combines information about the file path (`toString path`), existence (`builtins.pathExists`), and properties of the content (`builtins.stringLength` applied to `builtins.readFile`).
    *   **Use Case:** Understanding what's happening when interacting with files – confirming paths, checking existence, and getting basic metadata alongside the file read operation itself.
    *   **Code Link:** Section 5 traces information about a file read attempt, reporting existence and content length within the trace message generated by the custom function passed to `traceValFn`.

6.  **Safe File Reading (Error Handling with `tryEval`)**
    *   **Concept:** Introduces structured error handling. It defines a function (`readFileSafe`) that uses `throw` to signal a *catchable* error if a file doesn't exist (`builtins.pathExists` is false). `builtins.tryEval` is then used to *attempt* calling `readFileSafe`. `tryEval` catches any `throw` (or `abort`, or `assert` failure) and returns an attribute set indicating success (`{ success = true; value = ...; }`) or failure (`{ success = false; value = errorMessage; }`). This allows the program to continue even if an operation fails, unlike an uncaught `throw` or `abort`. `builtins.trace` is used here to report the *caught* error.
    *   **Use Case:** Implementing robust operations that might predictably fail (like reading optional files) without halting the entire evaluation.
    *   **Code Link:** Section 6 shows the `tryEval`/`throw` pattern to handle a non-existent file gracefully, tracing the error message if caught.

7.  **Custom Debug Utilities**
    *   **Concept:** Shows how to build reusable debugging helper functions by encapsulating common tracing patterns. It defines a `Debug` function that uses `lib.debug.traceValFn` internally to provide consistent trace output for different operations (like file reading and directory scanning).
    *   **Use Case:** Reducing boilerplate debugging code in larger projects by creating standardized tracing helpers for common tasks.
    *   **Code Link:** Section 7 defines and uses a custom `Debug` function to trace both `readFile` and `readDir` operations with informative, consistent messages.

8.  **Deep Structure Tracing (`lib.debug.traceSeq`)**
    *   **Concept:** Addresses Nix's lazy evaluation. `lib.debug.traceSeq` is designed to force the evaluation of elements within a list or the values within an attribute set *sequentially*, tracing each one as it's evaluated. Standard tracing might not evaluate deeper parts of a structure if they aren't explicitly used elsewhere.
    *   **Use Case:** Debugging issues related to lazy evaluation or inspecting the complete contents of potentially large or nested data structures where you want to ensure all parts are evaluated and observed.
    *   **Code Link:** Section 8 uses `traceSeq` to force evaluation and trace the top-level elements of `nestedStructure` and also the elements within `nestedStructure.moreNesting`.

9.  **Assertions (`assert`, `abort`, `lib.isInt`)**
    *   **Concept:** Shifts from *observing* behavior to *enforcing* it. The `assert condition; body` construct checks if `condition` is true. If not, evaluation stops with an error. `builtins.abort message` provides a way to stop evaluation immediately with a custom error message. Often combined as `assert condition || abort "Custom error"`. This section uses `assert` to validate function arguments (checking if `x` is `2`) and input types (`lib.isInt` to check if `n` represents an integer) before proceeding.
    *   **Use Case:** Guaranteeing preconditions, validating function inputs, or ensuring invariants hold within your code. This makes code more robust by failing early and clearly when assumptions are violated.
    *   **Code Link:** Section 9 demonstrates using `assert` with `|| abort` to validate a function's argument and an input variable's type using `lib.isInt`.

